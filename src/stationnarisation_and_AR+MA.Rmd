---
title: "R Notebook"
output: html_notebook
---
```{r}
#Supprime toutes les variables locales 
rm(list = ls())
```

```{r}
#On appelle le script de cleaningData (choisir l'emplacement de cleaningData.R)
path = file.choose()
#Choisir l'emplacement des donn√©es
source(path)
```



```{r}
summary(daily_data)
```

```{r}
#On dispose d'une observation de PT08.S3.NOX par jour pendant 341 jours (d'o√π start=1 :  premier jours, frequency = 1 : une observation par jour
ts_PT08.S3.NOx. = ts(daily_data$PT08.S3.NOx., start=1, frequency = 1)
plot(ts_PT08.S3.NOx., col="violetred2" )
```


```{r}
#On stationnarise la s√©rie
ts_stat_PT08.S3.NOx. = diff(ts_PT08.S3.NOx.)
plot(ts_stat_PT08.S3.NOx.)
```

```{r}
#On teste la stationnarit√© en utilisant le test de Dicky-Fuller : H0 correspond √† l'hypoth√®se de non stationnarit√© : pr√©sence d'une racine unitaire dans l'√©quation canonique de la s√©rie, ici la p-value est 0.01 donc on rejette H0 , la s√©rie est bien stationnaire
library(tseries)
test_stationnarity = adf.test(ts_stat_PT08.S3.NOx.)
print(test_stationnarity)
```

```{r}
#On enl√®ve les 10 derni√®res donn√©es 
ts_stat_PT08.S3.NOx._train_set = ts_stat_PT08.S3.NOx.[1:(length(ts_stat_PT08.S3.NOx.)-10 )]
length(ts_stat_PT08.S3.NOx._train_set)
```
```{r}
ts_stat_PT08.S3.NOx._train_set=ts(ts_stat_PT08.S3.NOx._train_set,start=1,frequency = 1)
```

```{r}
#On trace la fonction acf pour avoir une id√©e sur le mod√®les MA
acf(ts_stat_PT08.S3.NOx._train_set, main = "ACF",lag=20)
```

```{r}
#MA(2) model
fit_ma_model = arima(ts_stat_PT08.S3.NOx._train_set,order=c(0,0,2),include.mean=FALSE)
fit_ma_model
```
```{r}
tsdiag(fit_ma_model)
```


```{r}
#On trace la fonction acf pour avoir une id√©e sur le mod√®les AR
pacf(ts_stat_PT08.S3.NOx._train_set, main = "PACF",lag=20)
```
```{r}
#AR(5) model
fit_ar_model = arima(ts_stat_PT08.S3.NOx._train_set,order=c(5,0,0), include.mean = FALSE)
fit_ar_model
```
```{r}
tsdiag(fit_ar_model)
```

```{r}
AIC=matrix(0,ncol = 5,nrow=5)

for (i in 1:5){
  for (j in 1:5){
    AIC[i,j]=arima(ts_stat_PT08.S3.NOx._train_set,order=c(i,0,j),include.mean=FALSE)$aic
  }
}

colnames(AIC)<-c("MA1","MA2","MA3","MA4","MA5")
rownames(AIC)<-c("AR1","AR2","AR3","AR4","AR5")

AIC
```
Le min d'AIC est atteint pour le model ARMA(2,1)

```{r}
fit_arma_model=arima(ts_stat_PT08.S3.NOx._train_set,order = c(2,0,1),include.mean = FALSE)
fit_arma_model
```

```{r}
tsdiag(fit_arma_model)
```

```{r}
#Model Selection
AIC(fit_ma_model,fit_ar_model,fit_arma_model)
BIC(fit_ma_model,fit_ar_model,fit_arma_model)
```
Les critËres AIC et BIC sont les plus petits avec le modËle ARMA

```{r}
#Residuals
eps<-ts(fit_arma_model$residuals,frequency=1,start=1)
plot.ts(eps)

par(mfrow=c(1,1))
acf(eps,lag=100)
qqnorm(eps)
qqline(eps,col=2)

par(mfrow=c(1,2))
acf(eps,lag=100)
acf(eps^2,lag=100)


```

```{r}
#GARCH Model
library(fGarch)
library(xts)
library(astsa)

objf.garch <- function(vartheta,eps,n,sig2init,petit=sqrt(.Machine$double.eps),r0=10){
  omega<-vartheta[1]
  alpha<-vartheta[2]
  beta<-vartheta[3]
  sig2<-rep(0,n)
  sig2[1]<-sig2init
  for(t in 2:n){
    sig2[t]<-omega+alpha*eps[t-1]^2+beta*sig2[t-1]
  }
  qml<-mean(eps[(r0+1):n]^2/sig2[(r0+1):n]+log(sig2[(r0+1):n]))
  qml
}

VarAsymp<- function(omega,alpha,beta,eps,sig2init,petit,r0=10){
  n <- length(eps)
  dersigma2<-matrix(0,nrow=3,ncol=n)
  sig2<-rep(0,n)
  sig2[1]<-sig2init
  for(t in 2:n){
    vec<-c(1,eps[t-1]^2,sig2[t-1])
    sig2[t]<-omega+beta*sig2[t-1]+alpha*eps[t-1]^2
    dersigma2[1:3,t]<-vec/sig2[t]+beta*dersigma2[1:3,(t-1)]
  }
  eta <- eps[(r0+1):n]/sqrt(sig2)[(r0+1):n]
  eta <- eta/sd(eta)
  
  J<-dersigma2[1:3,(r0+1):n]%*%t(dersigma2[1:3,(r0+1):n])/(n-r0)
  kappa4<-mean(eta^4)
  
  {if(kappa(J)<1/petit) inv<-solve(J) else inv<-matrix(0,nrow=3,ncol=3)}
  var<-(kappa4-1)*inv
  list(var=var,residus=eta)
}

estimGARCH<- function(omega,alpha,beta,eps,petit=sqrt(.Machine$double.eps),r0=10)
{
  valinit<-c(omega,alpha,beta)
  n <- length(eps)
  sig2init<-var(eps[1:min(n,5)])
  res <- nlminb(valinit,objf.garch,lower=c(petit,0,0),
                upper=c(Inf,Inf,1), eps=eps,n=n,sig2init=sig2init)
  omega <- res$par[1]
  alpha<- res$par[2]
  beta <- res$par[3]
  var<-VarAsymp(omega,alpha,beta,eps,sig2init,petit=sqrt(.Machine$double.eps),r0=10)
  list(coef=c(omega,alpha,beta),residus=var$residus,var=var$var)
}
```

```{r}
#Estimation
par(mfrow=c(1,1))

omega_init<-0.01
alpha_init<-0.01
beta_init<-0.01

fitgarch<-estimGARCH(omega_init,alpha_init,beta_init,eps)
par<-fitgarch$coef
res<-fitgarch$residus
qqnorm(res)
qqline(res,col=2)
acf(res^2)

fitgarch_bis<-garchFit(~garch(1,1),ts_stat_PT08.S3.NOx._train_set)
coef(fitgarch_bis)
fitgarch_bis
```

```{r}
#Test beta=0

beta=par[3]
sigmabeta=fitgarch$var[3,3]
se=sqrt(sigmabeta)/sqrt(T)
t.value=beta/se
p.value=2*pnorm(-t.value)

print(p.value)
#ERREUR CAR TOUTES LES COMPOSANTES DE LA MATRICE VAR SONT NULLES
```

```{r}
#Test alpha=0

alpha=par[2]
sigmaalpha=fitgarch$var[2,2]
se=sqrt(sigmaalpha)/sqrt(T)
t.value=alpha/se
p.value=2*pnorm(-t.value)

print(p.value)

```